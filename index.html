<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Fractal Tree</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #0f172a;
      /* Dark slate background */
      font-family: sans-serif;
    }

    canvas {
      display: block;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="controls">
    <h3>Recursive Binary Tree</h3>
    <p>Phase: <span id="status">Growing...</span></p>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    let width, height;
    let treeData = null;

    // Configuration
    const MAX_DEPTH = 12;
    const TRUNK_LENGTH = 140;
    const TRUNK_WIDTH = 12;

    // Animation State
    let growthProgress = 0; // 0 to 1
    let time = 0;
    let isFullyGrown = false;

    // Resize handling
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Data Structure Construction ---
    // We pre-calculate random variations so the tree shape is stable
    // while animating. Otherwise, Math.random() in the draw loop causes static noise.

    function createBranch(depth) {
      if (depth === 0) return null;

      // Randomize branch length reduction (0.7 to 0.85)
      const lenMult = 0.7 + Math.random() * 0.15;

      // Randomize branch spread angle (20 to 35 degrees)
      const angleVary = (20 + Math.random() * 15) * (Math.PI / 180);

      return {
        lenMult: lenMult,
        angleVary: angleVary,
        left: createBranch(depth - 1),
        right: createBranch(depth - 1)
      };
    }

    function initTree() {
      treeData = {
        // The root only needs children, trunk logic is handled in draw
        left: createBranch(MAX_DEPTH),
        right: createBranch(MAX_DEPTH)
      };
    }

    // --- Rendering & Animation ---

    function drawBranch(x, y, length, angle, depth, node) {
      if (!node || depth <= 0) return;

      // 1. Calculate Wind Force
      // Wind affects higher branches (lower depth index) more strongly
      // We use a sine wave based on time and a unique offset per depth level
      const windForce = Math.sin(time * 0.002 + (MAX_DEPTH - depth) * 0.5);

      // Sway amount increases as the tree grows out
      const sway = windForce * 0.02 * (MAX_DEPTH - depth);

      const currentAngle = angle + sway;

      // 2. Calculate Endpoint
      const endX = x + Math.cos(currentAngle) * length;
      const endY = y + Math.sin(currentAngle) * length;

      // 3. Style & Draw
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(endX, endY);

      // Taper line width based on depth
      ctx.lineWidth = Math.max(1, (depth / MAX_DEPTH) * TRUNK_WIDTH);

      // Color interpolation: Brown (trunk) -> Green (leaves) -> Pink/White (flowers)
      if (depth > MAX_DEPTH * 0.6) {
        ctx.strokeStyle = `hsl(25, 40%, ${20 + (MAX_DEPTH - depth) * 5}%)`; // Woody Brown
      } else if (depth > MAX_DEPTH * 0.3) {
        ctx.strokeStyle = `hsl(120, 40%, ${30 + (MAX_DEPTH - depth) * 5}%)`; // Green leaves
      } else {
        ctx.strokeStyle = `hsl(330, 80%, 80%)`; // Pink flowers tips
      }

      ctx.lineCap = 'round';
      ctx.stroke();

      // 4. Recursive Calls
      // Calculate new length based on the node's pre-determined multiplier
      // Apply Growth: If not fully grown, scale length down based on progress
      const growthScale = Math.min(1, Math.max(0, (growthProgress * MAX_DEPTH) - (MAX_DEPTH - depth)));

      // Smooth growth transition
      if (growthScale > 0) {
        const nextLen = length * node.lenMult * (isFullyGrown ? 1 : growthScale);

        drawBranch(endX, endY, nextLen, currentAngle - node.angleVary, depth - 1, node.left);
        drawBranch(endX, endY, nextLen, currentAngle + node.angleVary, depth - 1, node.right);
      }
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);

      // Update time for wind
      time += 1;

      // Update Growth
      if (!isFullyGrown) {
        growthProgress += 0.005; // Growth speed
        if (growthProgress >= 1.2) { // 1.2 to ensure animation settles
          isFullyGrown = true;
          growthProgress = 1;
          statusEl.innerText = "Swaying in wind";
          statusEl.style.color = "#88ff88";
        }
      }

      // Start Drawing from bottom center
      const startX = width / 2;
      const startY = height;

      // Initial trunk setup
      const trunkLen = TRUNK_LENGTH * Math.min(1, growthProgress * 2); // Trunk grows first
      const startAngle = -Math.PI / 2; // Pointing up

      // Draw Root Trunk
      // We manually draw the first segment so the recursive function handles the split
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      const trunkEndX = startX + Math.cos(startAngle + (Math.sin(time * 0.002) * 0.01)) * trunkLen;
      const trunkEndY = startY + Math.sin(startAngle + (Math.sin(time * 0.002) * 0.01)) * trunkLen;

      ctx.lineWidth = TRUNK_WIDTH;
      ctx.strokeStyle = 'hsl(25, 40%, 20%)';
      ctx.lineCap = 'round';
      ctx.stroke();

      // Begin Recursion
      // Use the stored treeData structure
      if (treeData && trunkLen > 0) {
        // Pass the end of the trunk as the start of the branches
        drawBranch(trunkEndX, trunkEndY, trunkLen * 0.8, startAngle - 0.3, MAX_DEPTH, treeData.left);
        drawBranch(trunkEndX, trunkEndY, trunkLen * 0.8, startAngle + 0.3, MAX_DEPTH, treeData.right);
      }

      requestAnimationFrame(animate);
    }

    // Run
    initTree();
    animate();

  </script>
</body>

</html>
