# Assignment 8 — Queue Operations using Array and Linked List

Source program: [../8.c](../8.c)

Remark: The program supports Queue operations using (A) Array implementation and (B) Linked List implementation.

## Part A — Queue using Array

Remark: Array queue uses `frontA` and `rearA` (initially -1). Valid elements are from index `frontA` to `rearA`.

### Array Enqueue

Enqueue (Array): -

Input: Array Q[0...MAX-1], integers `frontA`, `rearA`, and integer `item`.

Output: Updated queue after inserting `item`, or overflow message.

Steps:

1. Start.
2. If (rearA == MAX - 1) then Print "Queue overflow" and Stop.
3. If (frontA == -1) then Set frontA = 0. EndIf.
4. Set rearA = rearA + 1.
5. Set Q[rearA] = item.
6. Print "Enqueued".
7. Stop.

### Array Dequeue

Dequeue (Array): -

Input: Array Q[0...MAX-1], integers `frontA`, `rearA`.

Output: Removes and prints the front element, or underflow message.

Steps:

1. Start.
2. If (frontA == -1 OR frontA > rearA) then Print "Queue underflow" and Stop.
3. Print Q[frontA] as dequeued element.
4. Set frontA = frontA + 1.
5. If (frontA > rearA) then Set frontA = -1 and Set rearA = -1. EndIf.
6. Stop.

### Array Display

Display (Array): -

Input: Array Q[0...MAX-1], integers `frontA`, `rearA`.

Output: Prints all queue elements from front to rear.

Steps:

1. Start.
2. If (frontA == -1 OR frontA > rearA) then Print "Queue is empty" and Stop.
3. For i = frontA to rearA do
4. Print Q[i].
5. EndFor.
6. Stop.

## Part B — Queue using Linked List

Remark: Linked list queue maintains pointers `frontL` and `rearL`.

### LL Enqueue

Enqueue (LL): -

Input: Pointers `frontL`, `rearL` and integer `item`.

Output: Updated queue after inserting `item` at the rear.

Steps:

1. Start.
2. Create newNode.
3. Set newNode->data = item and newNode->next = NULL.
4. If (rearL == NULL) then
5. Set frontL = newNode and Set rearL = newNode.
6. Else
7. Set rearL->next = newNode.
8. Set rearL = newNode.
9. EndIf.
10. Print "Enqueued".
11. Stop.

### LL Dequeue

Dequeue (LL): -

Input: Pointers `frontL`, `rearL`.

Output: Removes and prints the front element, or underflow message.

Steps:

1. Start.
2. If (frontL == NULL) then Print "Queue underflow" and Stop.
3. Set temp = frontL.
4. Set frontL = frontL->next.
5. Print temp->data as dequeued element.
6. Free temp.
7. If (frontL == NULL) then Set rearL = NULL. EndIf.
8. Stop.

### LL Display

Display (LL): -

Input: Pointer `frontL`.

Output: Prints all queue elements from front to rear.

Steps:

1. Start.
2. If (frontL == NULL) then Print "Queue is empty" and Stop.
3. Set temp = frontL.
4. While (temp != NULL) do
5. Print temp->data.
6. Set temp = temp->next.
7. EndWhile.
8. Stop.

## Menu (Program Flow)

Input: User choice and values.

Output: Performs chosen operation repeatedly until exit.

Steps:

1. Start.
2. Repeat
3. Read choice.
4. If choice == 1 then Read item and call Array Enqueue.
5. ElseIf choice == 2 then call Array Dequeue.
6. ElseIf choice == 3 then call Array Display.
7. ElseIf choice == 4 then Read item and call LL Enqueue.
8. ElseIf choice == 5 then call LL Dequeue.
9. ElseIf choice == 6 then call LL Display.
10. ElseIf choice == 7 then Stop.
11. Else Print "Invalid choice".
12. EndIf.
13. EndRepeat.
