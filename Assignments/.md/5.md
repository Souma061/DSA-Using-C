# Assignment 5 — Circular Linked List (Generalized Insert/Delete + Reverse/Search/Display)

Source program: [../5.c](../5.c)

Remark: This is a circular singly linked list. Last node’s `next` points back to `head`.

## Length

Length: -

Input: Head pointer `head` of a circular linked list.

Output: Integer `len` = number of nodes.

Steps:

1. Start.
2. If (head == NULL) then Return 0.
3. Set cnt = 0.
4. Set temp = head.
5. Do
6. Set cnt = cnt + 1.
7. Set temp = temp->next.
8. While (temp != head).
9. Return cnt.
10. Stop.

## Insert at position pos

Insertion: -

Input: Head pointer `head`, integer `item`, and position `pos` (1 to len+1).

Output: Updated circular list after inserting `item` at position `pos` or an error message.

Remark: Position is 1-based.

Steps:

1. Start.
2. If (pos < 1) then Print "Invalid position" and Stop.
3. Create newNode and set newNode->data = item.
4. If (pos == 1) then
5. If (head == NULL) then
6. Set head = newNode.
7. Set newNode->next = head.
8. Print "Inserted".
9. Stop.
10. Else
11. Set last = head.
12. While (last->next != head) do Set last = last->next. EndWhile.
13. Set last->next = newNode.
14. Set newNode->next = head.
15. Set head = newNode.
16. Print "Inserted".
17. Stop.
18. EndIf.
19. EndIf.
20. Set len = Length(head).
21. If (pos > len + 1) then Print "Invalid position" and Stop.
22. Set temp = head.
23. For i = 1 to pos - 2 do Set temp = temp->next. EndFor.
24. Set newNode->next = temp->next.
25. Set temp->next = newNode.
26. Print "Inserted".
27. Stop.

## Delete at position pos

Deletion: -

Input: Head pointer `head` and position `pos` (1 to len).

Output: Updated circular list after deleting node at position `pos` or an error message.

Steps:

1. Start.
2. If (head == NULL) then Print "List is empty" and Stop.
3. Set len = Length(head).
4. If (pos < 1 OR pos > len) then Print "Invalid position" and Stop.
5. If (pos == 1) then
6. If (head->next == head) then
7. Free head.
8. Set head = NULL.
9. Print "Deleted".
10. Stop.
11. Else
12. Set last = head.
13. While (last->next != head) do Set last = last->next. EndWhile.
14. Set toDelete = head.
15. Set last->next = head->next.
16. Set head = head->next.
17. Free toDelete.
18. Print "Deleted".
19. Stop.
20. EndIf.
21. EndIf.
22. Set temp = head.
23. For i = 1 to pos - 2 do Set temp = temp->next. EndFor.
24. Set toDelete = temp->next.
25. Set temp->next = toDelete->next.
26. Free toDelete.
27. Print "Deleted".
28. Stop.

## Reverse

Reverse: -

Input: Head pointer `head` of a circular linked list.

Output: Updated circular list with the order reversed.

Remark: After pointer reversal, the old head becomes the last node and must point to the new head.

Steps:

1. Start.
2. If (head == NULL OR head->next == head) then Stop.
3. Set prev = NULL.
4. Set current = head.
5. Set oldHead = head.
6. Do
7. Set next = current->next.
8. Set current->next = prev.
9. Set prev = current.
10. Set current = next.
11. While (current != head).
12. Set oldHead->next = prev.
13. Set head = prev.
14. Print "List reversed".
15. Stop.

## Search

Search: -

Input: Head pointer `head` and key `item`.

Output: "Found" with position if present, otherwise "Not found".

Steps:

1. Start.
2. If (head == NULL) then Print "List is empty" and Stop.
3. Set temp = head.
4. Set pos = 1.
5. Do
6. If (temp->data == item) then Print "Found at position pos" and Stop.
7. Set temp = temp->next.
8. Set pos = pos + 1.
9. While (temp != head).
10. Print "Not found".
11. Stop.

## Display

Display: -

Input: Head pointer `head`.

Output: Prints all elements in the circular list.

Steps:

1. Start.
2. If (head == NULL) then Print "List is empty" and Stop.
3. Set temp = head.
4. Do
5. Print temp->data.
6. Set temp = temp->next.
7. While (temp != head).
8. Stop.
