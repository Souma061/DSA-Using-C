# Assignment 4 — Doubly Linked List (Generalized Insert/Delete + Reverse/Search/Display)

Source program: [../4.c](../4.c)

Remark: The doubly linked list node has fields `data`, `prev`, and `next`. `head` points to the first node.

## Length

Length: -

Input: Head pointer `head` of a doubly linked list.

Output: Integer `len` = number of nodes.

Steps:

1. Start.
2. Set cnt = 0.
3. Set temp = head.
4. While (temp != NULL) do
5. Set cnt = cnt + 1.
6. Set temp = temp->next.
7. EndWhile.
8. Return cnt.
9. Stop.

## Insert at position pos

Insertion: -

Input: Head pointer `head`, integer `item`, and position `pos` (1 to len+1).

Output: Updated list after inserting `item` at position `pos` or an error message.

Remark: Position is 1-based.

Steps:

1. Start.
2. If (pos < 1) then Print "Invalid position" and Stop.
3. Create newNode.
4. Set newNode->data = item, newNode->prev = NULL, newNode->next = NULL.
5. If (pos == 1) then
6. Set newNode->next = head.
7. If (head != NULL) then Set head->prev = newNode. EndIf.
8. Set head = newNode.
9. Print "Inserted".
10. Stop.
11. EndIf.
12. Set len = Length(head).
13. If (pos > len + 1) then Print "Invalid position" and Stop.
14. Set temp = head.
15. For i = 1 to pos - 2 do
16. Set temp = temp->next.
17. EndFor.
18. Set newNode->next = temp->next.
19. Set newNode->prev = temp.
20. If (temp->next != NULL) then Set temp->next->prev = newNode. EndIf.
21. Set temp->next = newNode.
22. Print "Inserted".
23. Stop.

## Delete at position pos

Deletion: -

Input: Head pointer `head` and position `pos` (1 to len).

Output: Updated list after deleting node at position `pos` or an error message.

Steps:

1. Start.
2. If (head == NULL) then Print "List is empty" and Stop.
3. Set len = Length(head).
4. If (pos < 1 OR pos > len) then Print "Invalid position" and Stop.
5. If (pos == 1) then
6. Set temp = head.
7. Set head = head->next.
8. If (head != NULL) then Set head->prev = NULL. EndIf.
9. Free temp.
10. Print "Deleted".
11. Stop.
12. EndIf.
13. Set temp = head.
14. For i = 1 to pos - 2 do
15. Set temp = temp->next.
16. EndFor.
17. Set toDelete = temp->next.
18. Set temp->next = toDelete->next.
19. If (toDelete->next != NULL) then Set toDelete->next->prev = temp. EndIf.
20. Free toDelete.
21. Print "Deleted".
22. Stop.

## Reverse

Reverse: -

Input: Head pointer `head` of a doubly linked list.

Output: Updated list with the order of nodes reversed.

Remark: Reverse is done by swapping each node’s `prev` and `next` pointers.

Steps:

1. Start.
2. Set current = head.
3. Set temp = NULL.
4. While (current != NULL) do
5. Set temp = current->prev.
6. Set current->prev = current->next.
7. Set current->next = temp.
8. Set current = current->prev.
9. EndWhile.
10. If (temp != NULL) then Set head = temp->prev. EndIf.
11. Print "List reversed".
12. Stop.

## Search

Search: -

Input: Head pointer `head` and key `item`.

Output: "Found" with position if present, otherwise "Not found".

Steps:

1. Start.
2. Set temp = head.
3. Set pos = 1.
4. While (temp != NULL) do
5. If (temp->data == item) then Print "Found at position pos" and Stop.
6. Set temp = temp->next.
7. Set pos = pos + 1.
8. EndWhile.
9. Print "Not found".
10. Stop.

## Display

Display: -

Input: Head pointer `head`.

Output: Prints all elements from head to NULL.

Steps:

1. Start.
2. If (head == NULL) then Print "List is empty" and Stop.
3. Set temp = head.
4. While (temp != NULL) do
5. Print temp->data.
6. Set temp = temp->next.
7. EndWhile.
8. Stop.
